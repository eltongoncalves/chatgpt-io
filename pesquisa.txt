   public boolean validarRetentativaFiis(PagamentoRequest request, int receiveCount) {

        var fazerRetentativa = true;

        if (receiveCount > 1) {
            PagamentoStatus status = new PagamentoStatus();
            try {

                int numeroDias = (int) Duration.between(request.getDataPagamento().plusDays(-1), LocalDateTime.now()).toDays();
                var historicoTransacoesResponse = this.buscarHistoricoTransacoesUseCase.executar(
                        request.getFinalNumeroCartao(),
                        request.getNumeroBin(),
                        request.getCpf(),
                        numeroDias,
                        request.getFinalNumeroCartao()
                );

                var dataPagamento = request.getDataPagamento();
                var horaTransacao = dataPagamento.toLocalTime();
                var horaTransacaoPlus = dataPagamento.toLocalTime().plusMinutes(receiveCount * 15L);

                var transacoes = historicoTransacoesResponse.getResponseData().getListaAutorizacoes().stream().filter(
                        autorizacao -> autorizacao.getValorFaturamento().doubleValue() == request.getValorTransacao() &&
                                autorizacao.getDtTransacao().toString().equals(dataPagamento.toLocalDate().toString()) &&
                                LocalTime.parse(autorizacao.getHrTransacao()).isAfter(horaTransacao) &&
                                LocalTime.parse(autorizacao.getHrTransacao()).isBefore(horaTransacaoPlus)
                ).toList();

                if (transacoes.isEmpty()) {
                    throw new InternalServerErrorException("AUTORIZAÇÃO NÃO ENCONTRADA", "Falha ao verificar as autorizações");
                }

                status.setSucesso(true);
                status.setMensagem(MSG_SUCESSO);
                this.postaMensagemDeRetorno(request, status);

                fazerRetentativa = false;

            } catch (Exception e) {
                logError("validarRetentativaFiisError", Layer.INTERACTORS, "AUTORIZAÇÃO NÃO ENCONTRADA.", this.getClass(), e).log();
            }

        }

        return fazerRetentativa;

    }




RESPOSTA 

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.time.LocalDateTime;
import java.util.Collections;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class PagamentoServiceTest {

    @InjectMocks
    private PagamentoService pagamentoService; // Substitua pelo nome da classe que contém o método

    @Mock
    private BuscarHistoricoTransacoesUseCase buscarHistoricoTransacoesUseCase;

    private PagamentoRequest request;

    @BeforeEach
    void setup() {
        request = new PagamentoRequest();
        request.setDataPagamento(LocalDateTime.now().minusDays(1)); // Defina a data conforme necessário
        request.setFinalNumeroCartao("1234");
        request.setNumeroBin("5678");
        request.setCpf("12345678900");
        request.setValorTransacao(100.00); // Defina o valor conforme necessário
    }

    @Test
    void deveRetornarFazerRetentativaQuandoReceiveCountIgualAUm() {
        boolean resultado = pagamentoService.validarRetentativaFiis(request, 1);
        assertTrue(resultado);
    }

    @Test
    void deveRetornarFazerRetentativaQuandoTransacoesNaoEncontradas() {
        when(buscarHistoricoTransacoesUseCase.executar(any(), any(), any(), anyInt(), any()))
                .thenReturn(new HistoricoTransacoesResponse(Collections.emptyList()));

        boolean resultado = pagamentoService.validarRetentativaFiis(request, 2);

        assertTrue(resultado);
    }

    @Test
    void deveRetornarNaoFazerRetentativaQuandoTransacaoEncontrada() {
        Autorizacao autorizacao = new Autorizacao();
        autorizacao.setValorFaturamento(BigDecimal.valueOf(100.00));
        autorizacao.setDtTransacao(request.getDataPagamento().toLocalDate().toString());
        autorizacao.setHrTransacao(request.getDataPagamento().toLocalTime().toString());

        HistoricoTransacoesResponse historicoResponse = new HistoricoTransacoesResponse(List.of(autorizacao));

        when(buscarHistoricoTransacoesUseCase.executar(any(), any(), any(), anyInt(), any()))
                .thenReturn(historicoResponse);

        boolean resultado = pagamentoService.validarRetentativaFiis(request, 2);

        assertFalse(resultado);
    }

    @Test
    void deveRetornarFazerRetentativaQuandoExceptionLanca() {
        when(buscarHistoricoTransacoesUseCase.executar(any(), any(), any(), anyInt(), any()))
                .thenThrow(new RuntimeException("Erro"));

        boolean resultado = pagamentoService.validarRetentativaFiis(request, 2);

        assertTrue(resultado);
    }
}


